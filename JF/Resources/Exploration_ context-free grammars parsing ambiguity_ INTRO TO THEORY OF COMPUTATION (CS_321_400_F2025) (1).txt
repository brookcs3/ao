Speaker 1 (00:00):
Hi. In this video we're going to take a look at context free Grammars. Now remember that with right linear grammars, the productions on the left side, we could only have a single variable and no terminals. And on the right side we could have at most one variable and whatever terminals we wanted. But if we had a variable, it had to be at the right end after all of the terminal symbols. And with a context free grammar, on the other hand, we're going to keep that first restriction. So we're still going to have left sides that consist of just a single variable, but the right side of a production is going to be able to have whatever terminals and whatever variables we want, and they can be in whatever order we want. And that's going to give us more expressive power. So we'll start looking at a simple example, just A to the n, B to the N.

(01:19):
And the grammar for this can also be pretty simple. We'll just have two productions and let's try generating a string with this grammar. See where it gets us. So we can replace S with a s, B, we can do that again and again. And then we can at any point we want apply the third, sorry, the second production to get rid of the variable. So we can see that every time we apply the first production, we shove another A to the left and another B to the right. So the number of A's and B's will always be equal, and all of the A's will be on the left half and all of the B'S will be on the right half.

(02:33):
What about the empty string? Does the empty string belong to this language? In fact, it does because N can be equal to zero. And so the empty string has zero A's, and it has zero B's. And we can generate that string with this grammar by just choosing to apply the second production right off the bat and replace S with Lambda. Alright, let's take a look at a slightly more complex example. Let's try the language where error, the language of strings that have the number of A's in the string equal to the number of B's in the string.

(03:36):
And let's try this as a first stab. S goes to A, S, B, S can go to B, S, A, or S can go to Lambda. Is this going to work? Let's try it out. So S can go to A s, B, and we can apply that first production again, A, A, S, B, B, and then we can apply the second production. So we get A, B, S, A, B, B. And then we can apply the third production to get rid of the variable. And we have this. But we can kind of see from this walking through this derivation and from looking at these productions that this isn't going to work. This isn't going to get us all the strings in the language because we can see either we're shoving A B to the right and an A to the left or an A to the right and a B to the left. We're always going to have an A on the left, mirrored at the corresponding position on the right with A B, and a. B on the left is going to be mirrored at the corresponding position on the right with an A.

(05:27):
And those strings are part of the language, but there are a lot of other strings in the language that we can't get at this way. What can we do to fix it? Well, we can fix it actually by applying just one more production like this. So let's look at an example of a string that we couldn't get before that we hope to be able to get now. So one example that we couldn't get before is we could not generate the string A, B, B, A, because A is not mirrored by a B on the right. And this B is not mirrored by an A. And so we couldn't have generated this with what we had.

(06:37):
Can we generate it now? So let's first apply our new first production, and now let's apply the second production to the first S. And now let's apply the third production to the second S. And now we'll apply the last production to, whoops, sorry, SA. Okay, so we've gotten rid of the first variable and now we can get rid of the second variable. So and so we were able to generate this string that we couldn't generate before. And in fact, I'll go ahead and claim that because we can start off generating however many Ss we want by replacing Ss with more S's. And we can choose what order to apply the second and third productions to whichever S's we want, that we are in fact going to be able to get whatever permutation of A's and B's we want. But of course, we're still generating them in pairs. And so the number of as will still always have to be the same as the number of B's.

(08:43):
Okay, let's look at another slightly more complex example. So I'm going to, let's get rid of this and let's add just one little line there. So now we're going to look at the language where the number of A's is different from the number of Bs. And so strings where the number of A's and B's are equal are not going to be part of this language. What do we need to do to generate this language with a grammar? What productions will we need? Well, I'm going to use our previous grammar as partial inspiration for this. And I'm also going to use a strategy that creates two separate tracks.

(09:44):
So we're going to have one track for strings where the A's are more than the Bs. And the other track will be for strings that have more Bs than A's, and we're going to have to make that choice at the beginning, either S one or S two. And then S one can go to S one, S one, or it can go to a S one B or BS one A or variable A and S two can go to S two, S two or a S two B or BS two A or a new variable B.

(11:11):
A can go to the terminal A or it can go to AA and then B, to either B, I'm going to make a better arrow or it can go to B. B. So this is obviously based off of this grammar, but we have two separate tracks we commit to either S one where we'll end up with more a's than B's or S two where we'll end up with more Bs than A's. And once we choose a track, there's no way for us to switch tracks, so we're committed. You can see though, that the difference where we differ from our previous grammar is instead of going to Lambda, we go to one of these new variables that force us to add either extra A's or extra B's to the string. But again, because we can choose to end up with however many S's we want, and we can choose what order to apply these productions in, and we can put the extra A's or the extra B's anywhere in the string that we want to, and this is in fact going to work, it's because these second and third productions, except for the A or B at the end here, they're still generating the same number of A's and B's, but then we have to add at least one A or at least one B.

(13:13):
And so the number of A's and the number of B's have to end up different, but otherwise we can still have whatever permutation of those A's and B's we want to have is just we're either going to end up with more A's or more bs. And that's our last example for this video, and I'll see you in the next one.

