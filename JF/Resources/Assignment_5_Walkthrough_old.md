# Assignment 5 Walkthrough - Context-Free Grammars and Ambiguity

## Assignment Metadata
- **Assignment Title:** Assignment 5 - Context-Free Grammars, Parsing, and Ambiguity
- **Due Date:** Wednesday by 11:59pm
- **Total Points:** 60 points (12 points per problem)
- **Construct Folder Path:** C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5\Construct
- **Module Directory Path:** C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5
- **Part 2 (ZIP file) Needed:** YES - JFLAP files are required for CFG problems

## Submission Requirements

### Part 1: PDF File
Submit a single PDF file containing:
- All written explanations
- All CFG productions (Problems 1-2)
- Derivation tree (Problem 3)
- Ambiguity proofs (Problem 4)
- Theoretical proof (Problem 5)
- **SCREENSHOTS of JFLAP test cases** for Problems 1-4 (showing grammar + test results)

### Part 2: ZIP File
Submit a ZIP file containing all JFLAP files (.jff files):
- Problem1_CFG.jff
- Problem2_CFG.jff
- Problem3_Expression_Grammar.jff
- Problem4_Ambiguous_Grammar.jff
- Problem4_Unambiguous_Grammar.jff

**IMPORTANT:** Per professor's requirements, all grammar problems require JFLAP files AND screenshots showing test cases with both Accept and Reject examples.

---

## Problem 1: CFG for L = {a^n b^m : 2n ≤ m ≤ 3n}

### Question Details
- **Section:** 5.1 - Context-Free Grammar Construction
- **Points:** 12 points
- **Type:** CFG Construction

### JFLAP File Information
- **Filename:** Problem1_CFG.jff
- **Location:** C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5\Construct\Problem1_CFG.jff
- **Test Cases Required:** YES - Screenshot showing grammar + Multiple Run test results

**Test Strings to Use:**
- **Accept:** `` (empty), `abb`, `abbb`, `aabbbb`, `aabbbbb`, `aabbbbbb`, `aaabbbbbbb`
- **Reject:** `a`, `ab`, `abbbb`, `aab`, `aabb`, `aabbb`, `ba`, `aaabbbb`

### Written Answer

**Problem Statement:**
Create a context-free grammar for the language L = {a^n b^m : 2n ≤ m ≤ 3n}.

**Context-Free Grammar:**

```
S → aSbb | aSbbb | λ
```

**Explanation:**

The constraint 2n ≤ m ≤ 3n means that for each 'a' in the string, we need at least 2 'b's and at most 3 'b's. The grammar allows us to freely choose for each 'a' whether it "contributes" 2 or 3 'b's to the string.

**How the grammar works:**

1. **Production S → aSbb:**
   - Generates one 'a' followed by exactly 2 'b's
   - Then recurses with S to generate more

2. **Production S → aSbbb:**
   - Generates one 'a' followed by exactly 3 'b's
   - Then recurses with S to generate more

3. **Production S → λ:**
   - Base case (empty string)

**Key Insight:** By allowing each recursive step to choose between adding "abb" or "abbb", we can generate any string where the total number of b's is between 2n and 3n for n a's.

**Sample Derivations:**

*Example 1: n=1, m=2*
```
S ⇒ aSbb ⇒ abb
```
Check: 2(1) = 2 ≤ 2 ≤ 3 = 3(1) ✓

*Example 2: n=1, m=3*
```
S ⇒ aSbbb ⇒ abbb
```
Check: 2(1) = 2 ≤ 3 ≤ 3 = 3(1) ✓

*Example 3: n=2, m=5*
```
S ⇒ aSbb ⇒ aaSbbbbb ⇒ aabbbbb
```
Check: 2(2) = 4 ≤ 5 ≤ 6 = 3(2) ✓

**Correctness Justification:**

For any string a^n b^m where 2n ≤ m ≤ 3n, we can write m = 2k + 3(n-k) for some 0 ≤ k ≤ n. The grammar can generate this by using production S → aSbb exactly k times and production S → aSbbb exactly (n-k) times, followed by S → λ.

Conversely, any string generated by the grammar has the form a^n b^m where m is the sum of contributions from each recursive step (each contributing 2 or 3 b's), so 2n ≤ m ≤ 3n.

---

## Problem 2: CFG for L = {w ∈ {a,b}* : n_a(w) = 2n_b(w)}

### Question Details
- **Section:** 5.1 - Context-Free Grammar Construction
- **Points:** 12 points
- **Type:** CFG Construction

### JFLAP File Information
- **Filename:** Problem2_CFG.jff
- **Location:** C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5\Construct\Problem2_CFG.jff
- **Test Cases Required:** YES - Screenshot showing grammar + Multiple Run test results

**Test Strings to Use:**
- **Accept:** `` (empty), `aab`, `aba`, `baa`, `aabaab`, `aabbaa`, `baaaab`, `aabaabaab`
- **Reject:** `a`, `aa`, `b`, `ab`, `aabb`, `aaab`, `abab`, `aaabbb`

### Written Answer

**Problem Statement:**
Create a context-free grammar for the language L = {w ∈ {a,b}* : n_a(w) = 2n_b(w)}.

**Context-Free Grammar:**

```
S → aabS | abaS | baaS | SS | λ
```

**Explanation:**

The constraint n_a(w) = 2n_b(w) means the number of 'a's must be exactly twice the number of 'b's. Unlike Problem 1, the order of a's and b's can be arbitrary (they can be interleaved in any way).

**How the grammar works:**

1. **Productions S → aabS, S → abaS, S → baaS:**
   - Each generates one 'b' and two 'a's in different orderings
   - Covers all three possible arrangements of "aa" and "b": "aab", "aba", "baa"
   - Then recurses with S to generate more

2. **Production S → SS:**
   - Allows concatenation of two substrings, each with the 2:1 ratio
   - The concatenation also maintains the 2:1 ratio

3. **Production S → λ:**
   - Base case (empty string)

**Key Insight:** The three terminal-containing productions cover all possible local orderings of two a's and one b, while the SS production allows building complex strings by concatenating simpler ones.

**Sample Derivations:**

*Example 1: "aab"*
```
S ⇒ aabS ⇒ aab
```
Count: 2 a's, 1 b → 2 = 2(1) ✓

*Example 2: "baa"*
```
S ⇒ baaS ⇒ baa
```
Count: 2 a's, 1 b → 2 = 2(1) ✓

*Example 3: "aabaab"*
```
S ⇒ SS ⇒ aabS S ⇒ aab aabS ⇒ aabaab
```
Count: 4 a's, 2 b's → 4 = 2(2) ✓

*Example 4: "aabbaa"*
```
S ⇒ SS ⇒ aabS baaS ⇒ aab baa
```
Count: 4 a's, 2 b's → 4 = 2(2) ✓

**Correctness Justification:**

Every production either:
- Adds exactly 2 a's and 1 b (maintaining the 2:1 ratio)
- Concatenates two strings each with 2:1 ratio (preserving the ratio)
- Generates the empty string (trivially satisfying 0 = 2(0))

Therefore, every generated string has n_a = 2n_b. Conversely, any string with this property can be decomposed into units of "two a's and one b" and generated using the appropriate productions.

---

## Problem 3: Derivation Tree for (a + b) * c + d

### Question Details
- **Section:** 5.2 - Derivation Trees
- **Points:** 12 points
- **Type:** Derivation Tree Construction

### JFLAP File Information
- **Filename:** Problem3_Expression_Grammar.jff
- **Location:** C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5\Construct\Problem3_Expression_Grammar.jff
- **Test Cases Required:** YES - Screenshot showing grammar + Multiple Run test results

**Test Strings to Use:**
- **Accept:** `a`, `a+b`, `a*b`, `(a+b)*c`, `(a+b)*c+d`, `a+b+c`, `a*b*c`, `(a)`, `((a+b))*c`, `a+b*c`
- **Reject:** `+a`, `a+`, `a++b`, `(a+b`, `a+b)`, `()`, `*`, `e`, `ab`

**NOTE:** You can also use JFLAP's "Brute Force Parse" feature to generate the derivation tree for `(a+b)*c+d` and take a screenshot of it for inclusion in the PDF.

### Written Answer

**Problem Statement:**
Give the derivation tree for (a + b) * c + d, using the grammar in Example 5.12, but with I → a|b|c|d.

**Grammar:**
```
E → T | E + T
T → F | T * F
F → I | (E)
I → a | b | c | d
```

**String to Derive:** (a + b) * c + d

**Analysis:**
The string parses as: ((a + b) * c) + d

- Top level: E + T (addition)
- Left side: (a + b) * c (multiplication)
  - Left operand: (a + b) (parenthesized expression)
  - Right operand: c
- Right side: d

**Derivation Tree:**

```
                               E
                              /|\
                            /  |  \
                          E    +   T
                          |         |
                          T         F
                         /|\        |
                       /  |  \      I
                      T   *   F     |
                      |       |     d
                      F       I
                      |       |
                     (E)      c
                     /|\
                    / | \
                   (  E  )
                     /|\
                    / | \
                   E  +  T
                   |     |
                   T     F
                   |     |
                   F     I
                   |     |
                   I     b
                   |
                   a
```

**Reading the leaves left-to-right:** ( a + b ) * c + d ✓

**Leftmost Derivation:**
```
E
⇒ E + T                    [E → E + T]
⇒ T + T                    [E → T]
⇒ T * F + T                [T → T * F]
⇒ F * F + T                [T → F]
⇒ (E) * F + T              [F → (E)]
⇒ (E + T) * F + T          [E → E + T]
⇒ (T + T) * F + T          [E → T]
⇒ (F + T) * F + T          [T → F]
⇒ (I + T) * F + T          [F → I]
⇒ (a + T) * F + T          [I → a]
⇒ (a + F) * F + T          [T → F]
⇒ (a + I) * F + T          [F → I]
⇒ (a + b) * F + T          [I → b]
⇒ (a + b) * I + T          [F → I]
⇒ (a + b) * c + T          [I → c]
⇒ (a + b) * c + F          [T → F]
⇒ (a + b) * c + I          [F → I]
⇒ (a + b) * c + d          [I → d]
```

**Explanation:**
The derivation tree correctly represents operator precedence:
- Multiplication (*) binds tighter than addition (+)
- Parentheses force (a + b) to be evaluated first
- The final structure is ((a + b) * c) + d

**NOTE FOR PDF COMPILER:** The derivation tree should be drawn as a proper tree diagram. I've provided both a text representation and a leftmost derivation sequence. You may want to draw this tree graphically or use the LaTeX tree code provided below.

**LaTeX Tree Code (using qtree syntax):**
```latex
\Tree [.E
        [.E
          [.T
            [.T
              [.F
                (
                [.E
                  [.E
                    [.T
                      [.F
                        [.I a ]
                      ]
                    ]
                  ]
                  +
                  [.T
                    [.F
                      [.I b ]
                    ]
                  ]
                ]
                )
              ]
            ]
            *
            [.F
              [.I c ]
            ]
          ]
        ]
        +
        [.T
          [.F
            [.I d ]
          ]
        ]
      ]
```

---

## Problem 4: Ambiguity Proof

### Question Details
- **Section:** 5.2 - Ambiguity
- **Points:** 12 points
- **Type:** Two-part proof (ambiguity + not inherently ambiguous)

### JFLAP File Information
- **Ambiguous Grammar Filename:** Problem4_Ambiguous_Grammar.jff
- **Unambiguous Grammar Filename:** Problem4_Unambiguous_Grammar.jff
- **Location:** C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5\Construct\
- **Test Cases Required:** YES - Screenshots for BOTH grammars showing test results

**Test Strings to Use (for both grammars):**
- **Accept:** `` (empty), `ab`, `aabb`, `aaabbb`, `abab`, `aabbab`, `ababab`, `aaaabbbb`
- **Reject:** `a`, `b`, `aab`, `abb`, `ba`, `aabbb`, `aaabb`, `abba`

**IMPORTANT:** Use JFLAP's "Brute Force Parse" on the string `aabb` in the ambiguous grammar to show it has multiple parse trees. Take a screenshot showing both trees. This demonstrates the ambiguity visually.

### Written Answer

**Problem Statement:**
Show that the following grammar is ambiguous, but that the language it generates is not inherently ambiguous.

**Grammar:**
```
S → aSb | SS | λ
```

---

### Part A: Prove the Grammar is Ambiguous

**Definition:** A grammar is ambiguous if there exists at least one string that has two or more distinct derivation trees.

**Proof:**

We demonstrate that the string "aabb" has two different derivation trees.

**Derivation Tree 1:**
```
        S
       /|\
      / | \
     S  S  S
    /|\    /|\
   a S b  a S b
     |      |
     λ      λ
```

Leftmost derivation:
```
S ⇒ SS             [S → SS]
  ⇒ aSbS           [S → aSb]
  ⇒ abS            [S → λ]
  ⇒ abaSb          [S → aSb]
  ⇒ abaλb          [S → λ]
  ⇒ aabb
```

**Derivation Tree 2:**
```
        S
       /|\
      a S b
        |
       / \
      S   S
     /|\  |
    a S b λ
      |
      λ
```

Leftmost derivation:
```
S ⇒ aSb            [S → aSb]
  ⇒ aSSb           [S → SS]
  ⇒ aaSbSb         [S → aSb]
  ⇒ aaλbSb         [S → λ]
  ⇒ aabSb
  ⇒ aabλb          [S → λ]
  ⇒ aabb
```

**Conclusion:** Since "aabb" has two structurally different derivation trees, the grammar is **ambiguous**. ✓

---

### Part B: Prove the Language is NOT Inherently Ambiguous

**Definition:** A language is NOT inherently ambiguous if there exists at least one unambiguous grammar that generates it.

**Strategy:** We will construct an equivalent unambiguous grammar.

**Step 1: Identify the Language**

The language generated by S → aSb | SS | λ is:

L = {w ∈ {a,b}* : n_a(w) = n_b(w) and n_a(v) ≥ n_b(v) for every prefix v of w}

This is the language of balanced parentheses (if we think of 'a' as '(' and 'b' as ')').

**Step 2: Construct an Unambiguous Grammar**

```
S → aSbS | λ
```

**Step 3: Prove the New Grammar is Unambiguous**

**Claim:** The grammar G' with productions S → aSbS | λ is unambiguous.

**Proof by induction on string length:**

*Base case:* |w| = 0
- Only derivation: S ⇒ λ
- Unique derivation tree ✓

*Inductive case:* |w| > 0
- If w ∈ L(G') and |w| > 0, then w must start with 'a' (the only non-empty production is S → aSbS)
- We can write w = a w₁ b w₂ where:
  - w₁ is a balanced substring
  - w₂ is a balanced substring
- The matching 'b' for the first 'a' is uniquely determined (it's the first 'b' that balances all 'a's before it)
- By the inductive hypothesis, w₁ and w₂ each have unique derivation trees
- Therefore, w has a unique derivation tree ✓

By induction, every string in L(G') has a unique derivation tree, so G' is unambiguous.

**Step 4: Prove G and G' Generate the Same Language**

**(⊆) L(G') ⊆ L(G):**
- Any derivation S → aSbS in G' can be simulated in G as S → aSb followed by S → SS
- Therefore L(G') ⊆ L(G) ✓

**(⊇) L(G) ⊆ L(G'):**
- Both grammars generate balanced strings (equal a's and b's with the prefix property)
- The production S → SS in G allows parallel composition
- The production S → aSbS in G' allows sequential composition
- These are equivalent for balanced strings
- Therefore L(G) ⊆ L(G') ✓

Hence L(G) = L(G').

**Conclusion:** Since we have constructed an unambiguous grammar G' that generates the same language as G, the language is **NOT inherently ambiguous**. ✓

---

### Final Answer Summary

1. **The grammar S → aSb | SS | λ is ambiguous** because the string "aabb" has multiple distinct derivation trees.

2. **The language is NOT inherently ambiguous** because there exists an equivalent unambiguous grammar: S → aSbS | λ.

**NOTE FOR PDF COMPILER:** The two derivation trees for "aabb" should be drawn clearly to show the structural difference. Consider using tree diagrams similar to Figure 5.4 in the textbook.

---

## Problem 5: Theoretical Proof

### Question Details
- **Section:** 5.2 - Ambiguity Theory
- **Points:** 12 points
- **Type:** Formal proof

### Written Answer

**Problem Statement:**
Prove that if G is a context-free grammar in which no variable occurs on the left side of more than one production, then G is unambiguous.

**Theorem:** Let G = (V, T, S, P) be a context-free grammar such that each variable A ∈ V appears on the left-hand side of at most one production in P. Then G is unambiguous.

**Proof:**

We prove this by showing that every string w ∈ L(G) has a unique derivation tree.

Let w be an arbitrary string in L(G). We proceed by strong induction on the number of derivation steps required to generate w.

**Base case (n = 1):**

If w is derived in one step, then S → w is a production in P. Since S has at most one production, this derivation is unique. ✓

**Inductive hypothesis:**

Assume that for all strings derivable in k or fewer steps (k ≥ 1), the derivation tree is unique.

**Inductive step:**

Consider a string w derived in k + 1 steps. The derivation must start with some production S → α where α = α₁α₂...αₘ and each αᵢ ∈ V ∪ T.

Since S has at most one production, **this first step is uniquely determined**.

The string w can be partitioned as w = w₁w₂...wₘ where:
- If αᵢ ∈ T, then wᵢ = αᵢ (the terminal itself)
- If αᵢ ∈ V, then wᵢ is derived from αᵢ in fewer than k + 1 steps

For each αᵢ ∈ V:
- By the inductive hypothesis, the derivation tree for wᵢ from αᵢ is unique
- Since αᵢ has at most one production, the first step from αᵢ is unique
- All subsequent steps are unique by the inductive hypothesis

Since:
1. The first step (from S) is unique
2. Each subtree (from each αᵢ) is unique

The entire derivation tree for w is **uniquely determined**.

By the principle of mathematical induction, every string in L(G) has a unique derivation tree.

Therefore, G is **unambiguous**. ∎

---

**Key Insight:**

The fundamental reason this works is that ambiguity arises from having **choices** during derivation. If each variable has only one production, then at every step of the derivation, there is only one possible production to apply. This eliminates all choices, guaranteeing a unique derivation tree.

**Important Note:** This is a *sufficient* condition for unambiguity, but not a *necessary* condition. There are many unambiguous grammars where variables have multiple productions (e.g., the grammar in Example 5.12 of the textbook).

---

## Summary for PDF Compiler Agent

### Document Structure Recommendations

1. **Title Page:** "Assignment 5 - Context-Free Grammars and Ambiguity"
2. **Problem 1:** CFG construction with grammar, explanation, sample derivations, **AND JFLAP screenshot**
3. **Problem 2:** CFG construction with grammar, explanation, sample derivations, **AND JFLAP screenshot**
4. **Problem 3:** Derivation tree (draw the tree graphically) with leftmost derivation, **AND JFLAP screenshots**
5. **Problem 4:** Two-part proof with two derivation trees for "aabb", unambiguous grammar construction, **AND JFLAP screenshots for both grammars**
6. **Problem 5:** Formal proof by induction (no JFLAP file needed)

### JFLAP Screenshots Required

**Problem 1:** Screenshot showing:
- The grammar productions (S → aSbb | aSbbb | λ)
- Multiple Run test results with Accept/Reject outcomes
- At least 8 test strings (mix of accept and reject)

**Problem 2:** Screenshot showing:
- The grammar productions (S → aabS | abaS | baaS | SS | λ)
- Multiple Run test results with Accept/Reject outcomes
- At least 8 test strings (mix of accept and reject)

**Problem 3:** Screenshots showing:
- The expression grammar (E → T | E+T, etc.)
- Multiple Run test results for valid/invalid expressions
- **BONUS:** Use "Brute Force Parse" to generate the derivation tree for `(a+b)*c+d` and include that screenshot

**Problem 4:** Screenshots showing:
- **Screenshot 1:** Ambiguous grammar (S → aSb | SS | λ) with Multiple Run test results
- **Screenshot 2:** Unambiguous grammar (S → aSbS | λ) with Multiple Run test results
- **Screenshot 3:** Use "Brute Force Parse" on `aabb` in the ambiguous grammar to show MULTIPLE parse trees (this visually proves ambiguity!)

### Formatting Notes

- Use clear mathematical notation: → for productions, λ for empty string, ⇒ for derivation steps
- Number all pages
- Use proper tree diagrams for Problem 3 and Problem 4
- Ensure all grammar productions are clearly displayed
- Use consistent variable naming (S, A, B for variables; a, b, c, d for terminals)
- **CRITICAL:** Ensure JFLAP screenshots are clear, readable, and show both the grammar AND the test results

### Special Attention

- **Problem 3:** The derivation tree is complex - ensure it's drawn clearly with proper node labels. JFLAP can generate this for you!
- **Problem 4:** Two derivation trees must be shown side-by-side or clearly labeled as Tree 1 and Tree 2. Use JFLAP's "Brute Force Parse" to generate these!
- **Problem 5:** The proof should be formal and well-structured with clear base case and inductive step

---

## Files Created

### JFLAP Files (in Construct folder):
**C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5\Construct\**

- **Problem1_CFG.jff** - Grammar for L = {a^n b^m : 2n ≤ m ≤ 3n}
- **Problem2_CFG.jff** - Grammar for L = {w ∈ {a,b}* : n_a(w) = 2n_b(w)}
- **Problem3_Expression_Grammar.jff** - Expression grammar from Example 5.12
- **Problem4_Ambiguous_Grammar.jff** - Ambiguous grammar S → aSb | SS | λ
- **Problem4_Unambiguous_Grammar.jff** - Unambiguous grammar S → aSbS | λ

### Working Documents (in WorkingDocs folder):
**C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5\Construct\WorkingDocs\**

- **Assignment_5_Walkthrough.md** (this file) - Complete walkthrough with solutions
- **JFLAP_Test_Cases.md** - Comprehensive test case documentation
- Assignment_5_Analysis.md
- Problem_1_Final.md
- Problem_2_Solution.md
- Problem_3_Solution.md
- Problem_4_Solution.md
- Problem_5_Solution.md

---

## Next Steps

### Step 1: Create ZIP File for Part 2

Create a ZIP file containing all 5 JFLAP files:
- Problem1_CFG.jff
- Problem2_CFG.jff
- Problem3_Expression_Grammar.jff
- Problem4_Ambiguous_Grammar.jff
- Problem4_Unambiguous_Grammar.jff

Name the ZIP file: **Assignment5_JFLAP_Files.zip**

### Step 2: Take JFLAP Screenshots

Before creating the PDF, you need to:
1. Open JFLAP and load each .jff file
2. Use "Input → Multiple Run" to test the strings listed in this walkthrough
3. Take screenshots showing the grammar AND the test results
4. For Problem 3: Use "Brute Force Parse" on `(a+b)*c+d` to generate the derivation tree
5. For Problem 4: Use "Brute Force Parse" on `aabb` in the ambiguous grammar to show multiple parse trees

Save all screenshots in the Construct folder with descriptive names like:
- Problem1_JFLAP_Tests.png
- Problem2_JFLAP_Tests.png
- Problem3_JFLAP_Tests.png
- Problem3_Derivation_Tree.png
- Problem4_Ambiguous_Tests.png
- Problem4_Ambiguous_ParseTrees.png
- Problem4_Unambiguous_Tests.png

### Step 3: Create PDF for Part 1

**User:** Invoke the `interactive-pdf-compiler-midcourse` agent with this walkthrough file to create the final PDF submission for Assignment 5.

The path to provide to the agent:
```
C:\Users\Owner\FALL 2025\INTRO TO THEORY OF COMPUTATION (CS_321_400_F2025)\Modue 5\Construct\WorkingDocs\Assignment_5_Walkthrough.md
```

The agent will guide you through adding the JFLAP screenshots to the appropriate sections of the PDF.
