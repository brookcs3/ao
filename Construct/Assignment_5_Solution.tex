\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\setlength{\headheight}{14.49998pt}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{automata, positioning}
\usepackage{qtree}
\usepackage{url}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\titlelabel{}
\renewcommand{\thesection}{}
\renewcommand{\thesubsection}{}
\renewcommand{\thesubsubsection}{}
\setcounter{secnumdepth}{0}

% Set up code listings
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    showstringspaces=false,
    commentstyle=\color{gray},
    keywordstyle=\color{blue},
    stringstyle=\color{red}
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Cameron Brooks}
\lhead{CS321 Assignment 5}
\cfoot{\thepage}

% Title formatting
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

\title{Assignment 5: Context-Free Grammars, Parsing, and Ambiguity}
\author{Cameron Brooks \\
        CS321 Introduction to Theory of Computation \\
        Assignment 5}
\date{Wednesday by 11:59pm}

\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

% ============================================
% PROBLEM 1: CFG for L = {a^n b^m : 2n ≤ m ≤ 3n}
% ============================================

\section{Problem 1: CFG for L = \{$a^n b^m$ : $2n \leq m \leq 3n$\}}

\subsection{Problem Statement}
Create a context-free grammar for the language $L = \{a^n b^m : 2n \leq m \leq 3n\}$.

\subsection{Solution}

\textbf{Context-Free Grammar:}

\begin{align*}
S &\to aSbb \mid aSbbb \mid \lambda
\end{align*}

\textbf{Explanation:}

The constraint $2n \leq m \leq 3n$ means that for each `a' in the string, we need at least 2 `b's and at most 3 `b's. The grammar allows us to freely choose for each `a' whether it ``contributes'' 2 or 3 `b's to the string.

\textbf{How the grammar works:}

\begin{itemize}
\item \textbf{Production $S \to aSbb$:} Generates one `a' followed by exactly 2 `b's, then recurses with $S$ to generate more.

\item \textbf{Production $S \to aSbbb$:} Generates one `a' followed by exactly 3 `b's, then recurses with $S$ to generate more.

\item \textbf{Production $S \to \lambda$:} Base case (empty string).
\end{itemize}

\textbf{Key Insight:} By allowing each recursive step to choose between adding ``abb'' or ``abbb'', we can generate any string where the total number of b's is between $2n$ and $3n$ for $n$ a's.

\textbf{Sample Derivations:}

\textit{Example 1: $n=1, m=2$}
\begin{align*}
S &\Rightarrow aSbb \\
  &\Rightarrow abb
\end{align*}
Check: $2(1) = 2 \leq 2 \leq 3 = 3(1)$ \checkmark

\textit{Example 2: $n=1, m=3$}
\begin{align*}
S &\Rightarrow aSbbb \\
  &\Rightarrow abbb
\end{align*}
Check: $2(1) = 2 \leq 3 \leq 3 = 3(1)$ \checkmark

\textit{Example 3: $n=2, m=5$}
\begin{align*}
S &\Rightarrow aSbb \\
  &\Rightarrow aaSbbbbb \\
  &\Rightarrow aabbbbb
\end{align*}
Check: $2(2) = 4 \leq 5 \leq 6 = 3(2)$ \checkmark

\textbf{Correctness Justification:}

For any string $a^n b^m$ where $2n \leq m \leq 3n$, we can write $m = 2k + 3(n-k)$ for some $0 \leq k \leq n$. The grammar can generate this by using production $S \to aSbb$ exactly $k$ times and production $S \to aSbbb$ exactly $(n-k)$ times, followed by $S \to \lambda$.

Conversely, any string generated by the grammar has the form $a^n b^m$ where $m$ is the sum of contributions from each recursive step (each contributing 2 or 3 b's), so $2n \leq m \leq 3n$.

% ============================================
% PROBLEM 2: CFG for L = {w ∈ {a,b}* : n_a(w) = 2n_b(w)}
% ============================================

\section{Problem 2: CFG for L = \{$w \in \{a,b\}^*$ : $n_a(w) = 2n_b(w)$\}}

\subsection{Problem Statement}
Create a context-free grammar for the language $L = \{w \in \{a,b\}^* : n_a(w) = 2n_b(w)\}$.

\subsection{Solution}

\textbf{Context-Free Grammar:}

\begin{align*}
S &\to aabS \mid abaS \mid baaS \mid SS \mid \lambda
\end{align*}

\textbf{Explanation:}

The constraint $n_a(w) = 2n_b(w)$ means the number of `a's must be exactly twice the number of `b's. Unlike Problem 1, the order of a's and b's can be arbitrary (they can be interleaved in any way).

\textbf{How the grammar works:}

\begin{itemize}
\item \textbf{Productions $S \to aabS$, $S \to abaS$, $S \to baaS$:} Each generates one `b' and two `a's in different orderings. These cover all three possible arrangements of ``aa'' and ``b'': ``aab'', ``aba'', ``baa''. Then each recurses with $S$ to generate more.

\item \textbf{Production $S \to SS$:} Allows concatenation of two substrings, each with the 2:1 ratio. The concatenation also maintains the 2:1 ratio.

\item \textbf{Production $S \to \lambda$:} Base case (empty string).
\end{itemize}

\textbf{Key Insight:} The three terminal-containing productions cover all possible local orderings of two a's and one b, while the $SS$ production allows building complex strings by concatenating simpler ones.

\textbf{Sample Derivations:}

\textit{Example 1: ``aab''}
\begin{align*}
S &\Rightarrow aabS \\
  &\Rightarrow aab
\end{align*}
Count: 2 a's, 1 b $\to$ $2 = 2(1)$ \checkmark

\textit{Example 2: ``baa''}
\begin{align*}
S &\Rightarrow baaS \\
  &\Rightarrow baa
\end{align*}
Count: 2 a's, 1 b $\to$ $2 = 2(1)$ \checkmark

\textit{Example 3: ``aabaab''}
\begin{align*}
S &\Rightarrow SS \\
  &\Rightarrow aabS \, S \\
  &\Rightarrow aab \, aabS \\
  &\Rightarrow aabaab
\end{align*}
Count: 4 a's, 2 b's $\to$ $4 = 2(2)$ \checkmark

\textit{Example 4: ``aabbaa''}
\begin{align*}
S &\Rightarrow SS \\
  &\Rightarrow aabS \, baaS \\
  &\Rightarrow aab \, baa
\end{align*}
Count: 4 a's, 2 b's $\to$ $4 = 2(2)$ \checkmark

\textbf{Correctness Justification:}

Every production either:
\begin{itemize}
\item Adds exactly 2 a's and 1 b (maintaining the 2:1 ratio)
\item Concatenates two strings each with 2:1 ratio (preserving the ratio)
\item Generates the empty string (trivially satisfying $0 = 2(0)$)
\end{itemize}

Therefore, every generated string has $n_a = 2n_b$. Conversely, any string with this property can be decomposed into units of ``two a's and one b'' and generated using the appropriate productions.

% ============================================
% PROBLEM 3: Derivation Tree for (a + b) * c + d
% ============================================

\section{Problem 3: Derivation Tree for $(a + b) * c + d$}

\subsection{Problem Statement}
Give the derivation tree for $(a + b) * c + d$, using the grammar in Example 5.12, but with $I \to a \mid b \mid c \mid d$.

\subsection{Grammar}
\begin{align*}
E &\to T \mid E + T \\
T &\to F \mid T * F \\
F &\to I \mid (E) \\
I &\to a \mid b \mid c \mid d
\end{align*}

\subsection{Solution}

\textbf{String to Derive:} $(a + b) * c + d$

\textbf{Analysis:}

The string parses as: $((a + b) * c) + d$

\begin{itemize}
\item Top level: $E + T$ (addition)
\item Left side: $(a + b) * c$ (multiplication)
  \begin{itemize}
  \item Left operand: $(a + b)$ (parenthesized expression)
  \item Right operand: $c$
  \end{itemize}
\item Right side: $d$
\end{itemize}

\textbf{Derivation Tree:}

\begin{figure}[H]
\centering
\Tree [.E
        [.E
          [.T
            [.T
              [.F
                (
                [.E
                  [.E
                    [.T
                      [.F
                        [.I a ]
                      ]
                    ]
                  ]
                  +
                  [.T
                    [.F
                      [.I b ]
                    ]
                  ]
                ]
                )
              ]
            ]
            *
            [.F
              [.I c ]
            ]
          ]
        ]
        +
        [.T
          [.F
            [.I d ]
          ]
        ]
      ]
\caption{Derivation tree for $(a + b) * c + d$. Reading the leaves left-to-right yields: $(a+b)*c+d$}
\label{fig:derivation_tree}
\end{figure}

\textbf{Leftmost Derivation:}

\begin{align*}
E &\Rightarrow E + T                    && [E \to E + T] \\
  &\Rightarrow T + T                    && [E \to T] \\
  &\Rightarrow T * F + T                && [T \to T * F] \\
  &\Rightarrow F * F + T                && [T \to F] \\
  &\Rightarrow (E) * F + T              && [F \to (E)] \\
  &\Rightarrow (E + T) * F + T          && [E \to E + T] \\
  &\Rightarrow (T + T) * F + T          && [E \to T] \\
  &\Rightarrow (F + T) * F + T          && [T \to F] \\
  &\Rightarrow (I + T) * F + T          && [F \to I] \\
  &\Rightarrow (a + T) * F + T          && [I \to a] \\
  &\Rightarrow (a + F) * F + T          && [T \to F] \\
  &\Rightarrow (a + I) * F + T          && [F \to I] \\
  &\Rightarrow (a + b) * F + T          && [I \to b] \\
  &\Rightarrow (a + b) * I + T          && [F \to I] \\
  &\Rightarrow (a + b) * c + T          && [I \to c] \\
  &\Rightarrow (a + b) * c + F          && [T \to F] \\
  &\Rightarrow (a + b) * c + I          && [F \to I] \\
  &\Rightarrow (a + b) * c + d          && [I \to d]
\end{align*}

\textbf{Explanation:}

The derivation tree correctly represents operator precedence:
\begin{itemize}
\item Multiplication ($*$) binds tighter than addition ($+$)
\item Parentheses force $(a + b)$ to be evaluated first
\item The final structure is $((a + b) * c) + d$
\end{itemize}

% ============================================
% PROBLEM 4: Ambiguity Proof
% ============================================

\section{Problem 4: Ambiguity Proof}

\subsection{Problem Statement}
Show that the following grammar is ambiguous, but that the language it generates is not inherently ambiguous.

\textbf{Grammar:}
\begin{align*}
S &\to aSb \mid SS \mid \lambda
\end{align*}

\subsection{Part A: Prove the Grammar is Ambiguous}

\textbf{Definition:} A grammar is ambiguous if there exists at least one string that has two or more distinct derivation trees.

\textbf{Proof:}

We demonstrate that the string ``aabb'' has two different derivation trees.

\textbf{Derivation Tree 1:}

\begin{verbatim}
        S
       /|\
      / | \
     S  S  S
    /|\    /|\
   a S b  a S b
     |      |
     λ      λ
\end{verbatim}

Leftmost derivation:
\begin{align*}
S &\Rightarrow SS             && [S \to SS] \\
  &\Rightarrow aSbS           && [S \to aSb] \\
  &\Rightarrow abS            && [S \to \lambda] \\
  &\Rightarrow abaSb          && [S \to aSb] \\
  &\Rightarrow aba\lambda b   && [S \to \lambda] \\
  &\Rightarrow aabb
\end{align*}

\textbf{Derivation Tree 2:}

\begin{verbatim}
        S
       /|\
      a S b
        |
       / \
      S   S
     /|\  |
    a S b λ
      |
      λ
\end{verbatim}

Leftmost derivation:
\begin{align*}
S &\Rightarrow aSb            && [S \to aSb] \\
  &\Rightarrow aSSb           && [S \to SS] \\
  &\Rightarrow aaSbSb         && [S \to aSb] \\
  &\Rightarrow aa\lambda bSb  && [S \to \lambda] \\
  &\Rightarrow aabSb          \\
  &\Rightarrow aab\lambda b   && [S \to \lambda] \\
  &\Rightarrow aabb
\end{align*}

\textbf{Conclusion:} Since ``aabb'' has two structurally different derivation trees, the grammar is \textbf{ambiguous}. \checkmark

\subsection{Part B: Prove the Language is NOT Inherently Ambiguous}

\textbf{Definition:} A language is NOT inherently ambiguous if there exists at least one unambiguous grammar that generates it.

\textbf{Strategy:} We will construct an equivalent unambiguous grammar.

\textbf{Step 1: Identify the Language}

The language generated by $S \to aSb \mid SS \mid \lambda$ is:

$$L = \{w \in \{a,b\}^* : n_a(w) = n_b(w) \text{ and } n_a(v) \geq n_b(v) \text{ for every prefix } v \text{ of } w\}$$

This is the language of balanced parentheses (if we think of `a' as `(' and `b' as `)').

\textbf{Step 2: Construct an Unambiguous Grammar}

\begin{align*}
S &\to aSbS \mid \lambda
\end{align*}

\textbf{Step 3: Prove the New Grammar is Unambiguous}

\textbf{Claim:} The grammar $G'$ with productions $S \to aSbS \mid \lambda$ is unambiguous.

\textbf{Proof by induction on string length:}

\textit{Base case:} $|w| = 0$
\begin{itemize}
\item Only derivation: $S \Rightarrow \lambda$
\item Unique derivation tree \checkmark
\end{itemize}

\textit{Inductive case:} $|w| > 0$
\begin{itemize}
\item If $w \in L(G')$ and $|w| > 0$, then $w$ must start with `a' (the only non-empty production is $S \to aSbS$)
\item We can write $w = a w_1 b w_2$ where:
  \begin{itemize}
  \item $w_1$ is a balanced substring
  \item $w_2$ is a balanced substring
  \end{itemize}
\item The matching `b' for the first `a' is uniquely determined (it's the first `b' that balances all `a's before it)
\item By the inductive hypothesis, $w_1$ and $w_2$ each have unique derivation trees
\item Therefore, $w$ has a unique derivation tree \checkmark
\end{itemize}

By induction, every string in $L(G')$ has a unique derivation tree, so $G'$ is unambiguous.

\textbf{Step 4: Prove G and G' Generate the Same Language}

\textbf{($\subseteq$) $L(G') \subseteq L(G)$:}
\begin{itemize}
\item Any derivation $S \to aSbS$ in $G'$ can be simulated in $G$ as $S \to aSb$ followed by $S \to SS$
\item Therefore $L(G') \subseteq L(G)$ \checkmark
\end{itemize}

\textbf{($\supseteq$) $L(G) \subseteq L(G')$:}
\begin{itemize}
\item Both grammars generate balanced strings (equal a's and b's with the prefix property)
\item The production $S \to SS$ in $G$ allows parallel composition
\item The production $S \to aSbS$ in $G'$ allows sequential composition
\item These are equivalent for balanced strings
\item Therefore $L(G) \subseteq L(G')$ \checkmark
\end{itemize}

Hence $L(G) = L(G')$.

\textbf{Conclusion:} Since we have constructed an unambiguous grammar $G'$ that generates the same language as $G$, the language is \textbf{NOT inherently ambiguous}. \checkmark

\subsection{Final Answer Summary}

\begin{enumerate}
\item \textbf{The grammar $S \to aSb \mid SS \mid \lambda$ is ambiguous} because the string ``aabb'' has multiple distinct derivation trees.

\item \textbf{The language is NOT inherently ambiguous} because there exists an equivalent unambiguous grammar: $S \to aSbS \mid \lambda$.
\end{enumerate}

% ============================================
% PROBLEM 5: Theoretical Proof
% ============================================

\section{Problem 5: Theoretical Proof}

\subsection{Problem Statement}
Prove that if $G$ is a context-free grammar in which no variable occurs on the left side of more than one production, then $G$ is unambiguous.

\subsection{Solution}

\textbf{Theorem:} Let $G = (V, T, S, P)$ be a context-free grammar such that each variable $A \in V$ appears on the left-hand side of at most one production in $P$. Then $G$ is unambiguous.

\textbf{Proof:}

We prove this by showing that every string $w \in L(G)$ has a unique derivation tree.

Let $w$ be an arbitrary string in $L(G)$. We proceed by strong induction on the number of derivation steps required to generate $w$.

\textbf{Base case ($n = 1$):}

If $w$ is derived in one step, then $S \to w$ is a production in $P$. Since $S$ has at most one production, this derivation is unique. \checkmark

\textbf{Inductive hypothesis:}

Assume that for all strings derivable in $k$ or fewer steps ($k \geq 1$), the derivation tree is unique.

\textbf{Inductive step:}

Consider a string $w$ derived in $k + 1$ steps. The derivation must start with some production $S \to \alpha$ where $\alpha = \alpha_1 \alpha_2 \ldots \alpha_m$ and each $\alpha_i \in V \cup T$.

Since $S$ has at most one production, \textbf{this first step is uniquely determined}.

The string $w$ can be partitioned as $w = w_1 w_2 \ldots w_m$ where:
\begin{itemize}
\item If $\alpha_i \in T$, then $w_i = \alpha_i$ (the terminal itself)
\item If $\alpha_i \in V$, then $w_i$ is derived from $\alpha_i$ in fewer than $k + 1$ steps
\end{itemize}

For each $\alpha_i \in V$:
\begin{itemize}
\item By the inductive hypothesis, the derivation tree for $w_i$ from $\alpha_i$ is unique
\item Since $\alpha_i$ has at most one production, the first step from $\alpha_i$ is unique
\item All subsequent steps are unique by the inductive hypothesis
\end{itemize}

Since:
\begin{enumerate}
\item The first step (from $S$) is unique
\item Each subtree (from each $\alpha_i$) is unique
\end{enumerate}

The entire derivation tree for $w$ is \textbf{uniquely determined}.

By the principle of mathematical induction, every string in $L(G)$ has a unique derivation tree.

Therefore, $G$ is \textbf{unambiguous}. $\qed$

\subsection{Key Insight}

The fundamental reason this works is that ambiguity arises from having \textbf{choices} during derivation. If each variable has only one production, then at every step of the derivation, there is only one possible production to apply. This eliminates all choices, guaranteeing a unique derivation tree.

\textbf{Important Note:} This is a \textit{sufficient} condition for unambiguity, but not a \textit{necessary} condition. There are many unambiguous grammars where variables have multiple productions (e.g., the grammar in Example 5.12 of the textbook).

\end{document}
